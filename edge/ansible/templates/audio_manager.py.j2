#!/usr/bin/env python3

import subprocess
import logging
import pwd
import os
from pathlib import Path

logger = logging.getLogger(__name__)

def get_pactl_env():
    """Returns a suitable environment for running pactl from a systemd service."""
    try:
        # Get the UID of the 'pi' user, which is needed to find the PulseAudio socket
        pi_uid = pwd.getpwnam('pi').pw_uid
        env = os.environ.copy()
        env['XDG_RUNTIME_DIR'] = f'/run/user/{pi_uid}'
        return env
    except KeyError:
        logger.warning("Could not find user 'pi' to set XDG_RUNTIME_DIR for pactl. Audio control will likely fail.")
        return os.environ.copy()
    except Exception as e:
        logger.error(f"An unexpected error occurred while creating pactl environment: {e}")
        return os.environ.copy()

class AudioManager:
    """Handles all audio-related operations for the sculpture system."""
    
    def __init__(self, audio_config_path=None):
        # Audio configuration from Ansible templates (all.yml)
        self.audio_config = {
            'samplerate': '{{ audio_sample_rate }}',
            'device': '{{ mpv_audio_device }}',
            'format': '{{ mpv_audio_format }}'
        }
        self.is_muted = False
        self._last_mute_error = None
        logger.info(f"AudioManager initialized with config: {self.audio_config}")
        
    def set_volume(self, volume):
        """Set volume level (0-1 range)."""
        try:
            # Convert to percentage
            volume_percent = int(volume * 100)
            volume_percent = max(0, min(100, volume_percent))  # Clamp to 0-100
            
            logger.info(f"Setting volume to {volume_percent}%")
            subprocess.run([
                'pactl', 'set-sink-volume', 'sculpture_sink', f'{volume_percent}%'
            ], check=True, env=get_pactl_env())
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to set volume: {e}")
            raise
    
    def set_mute(self, mute):
        """Set mute state."""
        self.is_muted = bool(mute)  # Optimistically update state
        try:
            mute_flag = '1' if mute else '0'
            logger.info(f"Setting mute to {mute_flag} (True={mute})")
            subprocess.run([
                'pactl', 'set-sink-mute', 'sculpture_sink', mute_flag
            ], check=True, env=get_pactl_env())
            # Clear previous error on success
            self._last_mute_error = None
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to set mute: {e} - state may not be in sync. Check if 'sculpture_sink' exists with 'pactl list sinks'.")
            raise
    
    def get_mute_status(self, current_mode):
        """Get current mute status from the system."""
        try:
            # Only check for mute status if we're in a mode that produces audio
            if current_mode != "idle":
                mute_result = subprocess.run(
                    ['pactl', 'get-sink-mute', 'sculpture_sink'],
                    capture_output=True, text=True, check=True, env=get_pactl_env()
                )
                # Output is "Mute: yes" or "Mute: no"
                self.is_muted = 'yes' in mute_result.stdout.lower()
                # Clear previous error on success
                self._last_mute_error = None
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            # Log warning only once if sink is not found, to avoid spamming logs
            if self._last_mute_error is None:
                logger.warning(f"Could not get mute status: {e}. Using last known value. Further warnings will be suppressed.")
                self._last_mute_error = str(e)
        
        return self.is_muted
    
    def get_microphone_level(self):
        """Get microphone input level (peak) in dB."""
        mic_level = -60.0  # Default to silence
        try:
            # Use the special name @DEFAULT_SOURCE@ to listen to the system's default microphone
            mic_output = subprocess.check_output(
                "parec --raw --device=@DEFAULT_SOURCE@ | od -N 2 -d | head -n 1 | awk '{ val = $2; if (val < 0) val = -val; print 20*(log( (val+0.0001) / 32767) / log(10)) }'",
                shell=True,
                timeout=0.5,
                stderr=subprocess.PIPE,
                env=get_pactl_env()
            )
            mic_level = float(mic_output.strip())
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired, ValueError) as e:
            if isinstance(e, subprocess.CalledProcessError):
                logger.warning(f"Mic level check failed with error: {e.stderr.decode('utf-8').strip()}")
            pass  # Keep default on error
        
        return mic_level
    
    def get_output_level(self):
        """Get speaker output level (peak) in dB."""
        output_level = -60.0  # Default to silence
        try:
            # Use the special name sculpture_sink.monitor to listen to the sink's output
            output_output = subprocess.check_output(
                "parec --raw --device=sculpture_sink.monitor | od -N 2 -d | head -n 1 | awk '{ val = $2; if (val < 0) val = -val; print 20*(log( (val+0.0001) / 32767) / log(10)) }'",
                shell=True,
                timeout=0.5,
                stderr=subprocess.PIPE,
                env=get_pactl_env()
            )
            output_level = float(output_output.strip())
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired, ValueError) as e:
            if isinstance(e, subprocess.CalledProcessError):
                logger.warning(f"Output level check failed with error: {e.stderr.decode('utf-8').strip()}")
            pass  # Keep default on error
        
        return output_level 